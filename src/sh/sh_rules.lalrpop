use std::str::FromStr;
use crate::sh::sh_ast::{Command, Word, Words, Assignment, Assignments, Parameters, OpCommand};

#[LALR]
#[no_skip_whitespace]
grammar;

match {
    r#"(?:[^\s'"\\$\(\)\{\}><\&\|&=]|\\.)*"# => WORD,
    r"'(?:[^'\\]|\\.)*'" => SINGLE_QUOTES_WORD,
    "=" => EQUAL,
    "$" => EXPAND,
    "(" => LP,
    ")" => RP,
    "{" => LB,
    "}" => RB,
    "|" => PIPE,
    "||" => OR,
    "&" => BACKGROUND,
    "&&" => AND,
    ">" => OUTPUT_REDIRECT,
    "2>" => ERROR_REDIRECT,
    "&>" => OUTPUT_ERROR_REDIRECT,
    "<" => INPUT_REDIRECT,
    ">>" => OUTPUT_REDIRECT_APPEND,
    "2>>" => ERROR_REDIRECT_APPEND,
    "&>>" => OUTPUT_ERROR_REDIRECT_APPEND,
    ";" => SEQUENCE
} else {
    r"[[:digit:]]+" => NUMBER,
    r"\s+" => WS
}

pub Command: Box<Command> = {
    <s1:Command> SEQUENCE <s2:PipeCommand>=> Box::new (Command::SequentialCommand (s1, s2)),
    <s1:Command> SEQUENCE WS <s2:PipeCommand>=> Box::new (Command::SequentialCommand (s1, s2)),
    <s:PipeCommand> => s
};

PipeCommand: Box<Command> = {
    <s1:PipeCommand> PIPE <s2:AndOrCommand>=> Box::new (Command::PipeCommand (s1, s2)),
    <s1:PipeCommand> PIPE WS <s2:AndOrCommand>=> Box::new (Command::PipeCommand (s1, s2)),
    <s:AndOrCommand> => s
};

AndOrCommand: Box<Command> = {
    <s1:AndOrCommand> AND <s2:SimpleCommand>=> Box::new (Command::AndOrCommand(s1, s2, OpCommand::AND)),
    <s1:AndOrCommand> AND WS <s2:SimpleCommand>=> Box::new (Command::AndOrCommand(s1, s2, OpCommand::AND)),
    <s1:AndOrCommand> OR <s2:SimpleCommand>=> Box::new (Command::AndOrCommand(s1, s2, OpCommand::OR)),
    <s1:AndOrCommand> OR WS <s2:SimpleCommand>=> Box::new (Command::AndOrCommand(s1, s2, OpCommand::OR)),
    <s:SimpleCommand> => s
};

SimpleCommand: Box<Command> = {
    <a:Assignments> WS <mut w:Words> => {
        let s = Box::new (Command::SimpleCommand {
            assignments: a,
            words: Box::new (w),
            parameters: Box::new (Parameters::new ())
        });
        s
    },
    <a:Assignments> WS <w:Words> WS <p:Params> => {
        let s = Box::new (Command::SimpleCommand {
            assignments: a,
            words: Box::new (w),
            parameters: p
        });
        s
    },
    <mut w:Words> => {
        let s = Box::new (Command::SimpleCommand {
            assignments: Box::new (Assignments::new ()),
            words: Box::new (w),
            parameters: Box::new (Parameters::new ())
        });
        s
    },
    <w:Words> WS <p:Params> => {
        let s = Box::new (Command::SimpleCommand {
            assignments: Box::new (Assignments::new ()),
            words: Box::new (w),
            parameters: p
        });
        s
    }
};

Params: Box<Parameters> = {
    => Box::new (Parameters::new ()),
    <w:Words> => {
        let mut p = Box::new (Parameters::new ());
        (*p).push (w);
        p
    },
    <w:Words> WS <mut p:Params> => {
        (*p).insert (0, w);
        p
    }
}

Assignments: Box<Assignments> = {
    <mut n:Assignments> WS <a:Assignment> => {
        (*n).insert (0, a);
        n
    },
    <a:Assignment> => {
        let mut n = Box::new (Assignments::new ());
        (*n).push (a);
        n
    }
};

Assignment: Assignment = {
    <w1:WORD> EQUAL <w2:Words> => {
        let a = Assignment {
            variable: w1.to_string (),
            values: Box::new (w2)
        };
        a
    },
    <w:WORD> EQUAL => {
        let a = Assignment {
            variable: w.to_string (),
            values: Box::new (Words::new ())
        };
        a
    }
};

Words: Words = {
    <w:Word> => {
        let mut words = Words::new ();
        words.push (w);
        words
    },
    <w:Word><mut e:Words> => 
    {
        e.insert (0, w);
        e
    }
}

Word: Word = {
    <w:WORD> => {
        Word::Word (w.to_string())
    },
    <sq: SINGLE_QUOTES_WORD> => {
        Word::Word(sq[1..sq.len()-1].to_string())
    },
    <e:Expand> => e
};

Expand: Word = {
    EXPAND <w:WORD> => {
        Word::Expand (w.to_string())
    },
    EXPAND LB <w:WORD> RB => {
        Word::Expand (w.to_string())
    },
    EXPAND LP <s:Command> RP => {
        Word::Execute (s)
    }
};




